package groups

import (
	"fmt"

	"fiatjaf.com/nostr"

	"github.com/fiatjaf/pyramid/global"
	"github.com/fiatjaf/pyramid/layout"
	"github.com/fiatjaf/pyramid/pyramid"
)

templ listGroupsPage(loggedUser nostr.PubKey) {
	@layout.Layout(loggedUser, "groups") {
		<div class="max-w-3xl mx-auto">
			<h1 class="text-4xl font-bold mb-4">groups</h1>
			<div class="space-y-4 text-gray-700 dark:text-gray-300">
				<p class="text-lg leading-relaxed">
					the groups relay implements NIP-29: moderated group chat functionality.
				</p>
				<div class="bg-blue-50/50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-xl p-4">
					<h2 class="font-semibold text-gray-800 dark:text-gray-100 mb-2">how it works:</h2>
					<ul class="list-disc list-inside space-y-1 text-sm">
						<li>members can create groups</li>
						<li>group policies are provided at creation time</li>
						<li>as long as the group creator allows, non-members can join these groups freely</li>
					</ul>
				</div>
			</div>
			if pyramid.IsRoot(loggedUser) {
				@layout.SubRelaySettings("groups", global.Settings.Groups.Enabled, global.Settings.Groups.Name, global.Settings.Groups.Description, global.Settings.Groups.Icon, global.Settings.Groups.HTTPBasePath)
			}
			// groups table section
			if State != nil {
				<div class="mt-8">
					<h3 class="text-lg font-semibold mb-4 dark:text-stone-200">existing groups</h3>
					if State.Groups.Size() == 0 {
						<p class="text-sm text-stone-600 dark:text-stone-400">no groups created yet</p>
					} else {
						<div class="overflow-x-auto">
							<table class="min-w-full divide-y divide-stone-200 dark:divide-stone-700">
								<thead class="bg-stone-50 dark:bg-stone-800">
									<tr>
										<th class="px-4 py-3 text-xs font-medium text-stone-500 dark:text-stone-400 uppercase tracking-wider">group id</th>
										<th class="px-4 py-3 text-xs font-medium text-stone-500 dark:text-stone-400 uppercase tracking-wider">group</th>
										<th class="px-4 py-3 text-xs font-medium text-stone-500 dark:text-stone-400 uppercase tracking-wider">members</th>
										<th class="px-4 py-3 text-xs font-medium text-stone-500 dark:text-stone-400 uppercase tracking-wider">moderators</th>
										<th class="px-4 py-3 text-xs font-medium text-stone-500 dark:text-stone-400 uppercase tracking-wider">closed</th>
										<th class="px-4 py-3 text-xs font-medium text-stone-500 dark:text-stone-400 uppercase tracking-wider">private</th>
									</tr>
								</thead>
								<tbody class="bg-white dark:bg-stone-900 divide-y divide-stone-200 dark:divide-stone-700">
									for _, group := range State.Groups.Range {
										if pyramid.IsRoot(loggedUser) || !group.Private {
											<tr>
												<td class="px-4 py-3 text-sm text-center">
													<a
														href={ "/groups/" + group.Address.ID }
														class="text-stone-600 dark:text-stone-400 hover:underline"
													>{ group.Address.ID }</a>
												</td>
												<td class="px-4 py-3 text-sm text-center">
													<a
														href={ "/groups/" + group.Address.ID }
														class="font-medium text-stone-900 dark:text-stone-100 hover:underline"
														title={ group.About }
													>{ group.Name }</a>
												</td>
												<td class="px-4 py-3 text-sm text-center text-stone-600 dark:text-stone-400">{ fmt.Sprint(len(group.Members)) }</td>
												<td class="px-4 py-3 text-sm text-center">
													<div class="space-y-1">
														for pubkey, roles := range group.Members {
															if len(roles) > 0 {
																<div class="flex items-center gap-2">
																	<nostr-name pubkey={ pubkey.Hex() } class="text-stone-700 dark:text-stone-300">{ pubkey.Hex() }</nostr-name>
																	<span class="text-xs text-stone-500 dark:text-stone-500">
																		(
																		for i, role := range roles {
																			if i > 0 {
																				,
																			}
																			{ role.Name }
																		}
																		)
																	</span>
																</div>
															}
														}
													</div>
												</td>
												<td class="px-4 py-3 text-sm text-center">
													if group.Closed {
														☑
													} else {
														☐
													}
												</td>
												<td class="px-4 py-3 text-sm text-center">
													if group.Private {
														☑
													} else {
														☐
													}
												</td>
											</tr>
										}
									}
								</tbody>
							</table>
						</div>
					}
				</div>
				// my groups section
				if loggedUser != nostr.ZeroPK {
					<div class="mt-8">
						<h3 class="text-lg font-semibold mb-4 dark:text-stone-200">my groups</h3>
						<div class="overflow-x-auto">
							<table class="min-w-full divide-y divide-stone-200 dark:divide-stone-700">
								<thead class="bg-stone-50 dark:bg-stone-800">
									<tr>
										<th class="px-4 py-3 text-xs font-medium text-stone-500 dark:text-stone-400 uppercase tracking-wider">group id</th>
										<th class="px-4 py-3 text-xs font-medium text-stone-500 dark:text-stone-400 uppercase tracking-wider">group</th>
										<th class="px-4 py-3 text-xs font-medium text-stone-500 dark:text-stone-400 uppercase tracking-wider">members</th>
										<th class="px-4 py-3 text-xs font-medium text-stone-500 dark:text-stone-400 uppercase tracking-wider">moderators</th>
										<th class="px-4 py-3 text-xs font-medium text-stone-500 dark:text-stone-400 uppercase tracking-wider">closed</th>
										<th class="px-4 py-3 text-xs font-medium text-stone-500 dark:text-stone-400 uppercase tracking-wider">private</th>
									</tr>
								</thead>
								<tbody class="bg-white dark:bg-stone-900 divide-y divide-stone-200 dark:divide-stone-700">
									for _, group := range State.Groups.Range {
										if _, isMember := group.Members[loggedUser]; isMember {
											<tr>
												<td class="px-4 py-3 text-sm text-center">
													<a
														href={ "/groups/" + group.Address.ID }
														class="text-stone-600 dark:text-stone-400 hover:underline"
													>{ group.Address.ID }</a>
												</td>
												<td class="px-4 py-3 text-sm text-center">
													<a
														href={ "/groups/" + group.Address.ID }
														class="font-medium text-stone-900 dark:text-stone-100 hover:underline"
														title={ group.About }
													>{ group.Name }</a>
												</td>
												<td class="px-4 py-3 text-sm text-center text-stone-600 dark:text-stone-400">{ fmt.Sprint(len(group.Members)) }</td>
												<td class="px-4 py-3 text-sm text-center">
													<div class="space-y-1">
														for pubkey, roles := range group.Members {
															if len(roles) > 0 {
																<div class="flex items-center gap-2">
																	<nostr-name pubkey={ pubkey.Hex() } class="text-stone-700 dark:text-stone-300">{ pubkey.Hex() }</nostr-name>
																	<span class="text-xs text-stone-500 dark:text-stone-500">
																		(
																		for i, role := range roles {
																			if i > 0 {
																				,
																			}
																			{ role.Name }
																		}
																		)
																	</span>
																</div>
															}
														}
													</div>
												</td>
												<td class="px-4 py-3 text-sm text-center">
													if group.Closed {
														☑
													} else {
														☐
													}
												</td>
												<td class="px-4 py-3 text-sm text-center">
													if group.Private {
														☑
													} else {
														☐
													}
												</td>
											</tr>
										}
									}
								</tbody>
							</table>
						</div>
					</div>
				}
				// create new group form - visible for all logged relay members
				if pyramid.IsMember(loggedUser) {
					<div
						class="mt-8"
						x-data="{
							groupName: '',
							description: '',
							imageUrl: '',
							closed: false,
							private: false,
							creating: false,
							groupsRelayURL: window.location.href
								.replace('http', 'ws')
								.split('/')
								.slice(0, 3)
								.join('/'),
							async createGroup() {
								if (!this.groupName.trim()) {
									alert('group name is required');
									return;
								}

								try {
									creating = true;

									// generate random readable id
									const v = ['a', 'e', 'i', 'o', 'u', 'ay', 'ey', 'oy', 'ou', 'ia', 'ea', 'ough', 'oo', 'ee', 'argh']
									const c = ['p', 'b', 't', 'd', 'k', 'g', 'ch', 'sh', 'th', 'f', 'v', 's', 'z', 'l', 'r', 'm', 'n', 'pl', 'bl', 'cl', 'gl', 'pr', 'br', 'tr', 'dr', 'kr', 'gr', 'fl', 'sl', 'fr', 'thr', 'str', 'sk', 'sp', 'st']
									const n = 6 + Math.random()*2|0, s = [c, v]
									Math.random() < 0.5 && s.reverse()
									groupId = Array.from({length: n}, (_, i) => s[i%2].splice(Math.random()*s[i%2].length|0, 1)).join('')

									// create-group event
									await this.publishEvent(await window.nostr.signEvent({
										kind: 9007,
										created_at: Math.floor(Date.now() / 1000),
										tags: [
											['h', groupId]
										],
										content: ''
									}))

									// edit-metadata event
									await this.publishEvent(await window.nostr.signEvent({
										kind: 9002,
										created_at: Math.floor(Date.now() / 1000),
										tags: [
											['h', groupId],
											['name', this.groupName],
											...(this.description ? [['about', this.description]] : []),
											...(this.imageUrl ? [['picture', this.imageUrl]] : []),
											...(this.closed ? [['closed']] : [['open']]),
											...(this.private ? [['private']] : [['public']])
										],
										content: ''
									}))

									alert('group created successfully!')
									window.location.reload()
								} catch (error) {
									console.error('error creating group:', error)
									alert('failed to create group: ' + error.message)
								} finally {
									creating = false
								}
							},
							async publishEvent(event) {
								return new Promise((resolve, reject) => {
									const ws = new WebSocket(this.groupsRelayURL)
									let timeout = setTimeout(() => {
										ws.close()
										reject(new Error('timeout waiting for relay response'))
									}, 5000)

									ws.onopen = () => {
										ws.send(JSON.stringify(['EVENT', event]))
									}

									ws.onmessage = async (msg) => {
										const message = JSON.parse(msg.data)
										switch (message[0]) {
											case 'OK': {
												if (message[3].startsWith('auth-required:')) {
													await new Promise(resolve => setTimeout(resolve, 500))
													ws.send(JSON.stringify(['EVENT', event]))
												} else if (message[2] === true && message[1] === event.id) {
													resolve()
													clearTimeout(timeout)
													ws.onmessage = null
													ws.close()
												} else if (message[2] === false) {
													reject(new Error(message[3] || 'event rejected by relay'))
													clearTimeout(timeout)
													ws.onmessage = null
													ws.close()
												}
												break
											}
											case 'AUTH': {
												ws.send(JSON.stringify(['AUTH', await window.nostr.signEvent({
													created_at: Math.round(Date.now() / 1000),
													kind: 22242,
													content: '',
													tags: [
														['relay', this.groupsRelayURL],
														['challenge', message[1]]
													]
												})]))
												break
											}
										}
									}

									ws.onerror = () => {
										clearTimeout(timeout)
										ws.close()
										reject(new Error('websocket connection error'))
									}
								})
							}
						}"
					>
						<h3 class="text-lg font-semibold mb-4 dark:text-stone-200">create new group</h3>
						<form
							class="space-y-6"
							@submit.prevent="createGroup()"
						>
							<div class="space-y-4">
								<div>
									<label for="group_name" class="block text-sm font-medium text-stone-700 dark:text-stone-300 mb-1">
										group name <span class="text-red-500">*</span>
									</label>
									<input
										type="text"
										id="group_name"
										name="group_name"
										x-model="groupName"
										required
										class="w-full px-3 py-2 border border-stone-300 dark:border-stone-600 rounded-lg bg-white dark:bg-stone-800 text-stone-900 dark:text-stone-100 focus:outline-none focus:ring-2 focus:ring-stone-500"
									/>
								</div>
								<div>
									<label for="group_description" class="block text-sm font-medium text-stone-700 dark:text-stone-300 mb-1">
										description
									</label>
									<textarea
										id="group_description"
										name="description"
										x-model="description"
										rows="2"
										class="w-full px-3 py-2 border border-stone-300 dark:border-stone-600 rounded-lg bg-white dark:bg-stone-800 text-stone-900 dark:text-stone-100 focus:outline-none focus:ring-2 focus:ring-stone-500"
									></textarea>
								</div>
								<div>
									<label for="group_image" class="block text-sm font-medium text-stone-700 dark:text-stone-300 mb-1">
										image url
									</label>
									<input
										type="url"
										id="group_image"
										name="image_url"
										x-model="imageUrl"
										class="w-full px-3 py-2 border border-stone-300 dark:border-stone-600 rounded-lg bg-white dark:bg-stone-800 text-stone-900 dark:text-stone-100 focus:outline-none focus:ring-2 focus:ring-stone-500"
									/>
								</div>
							</div>
							<div class="space-y-3">
								<div class="flex items-center">
									<input
										type="checkbox"
										id="group_closed"
										name="closed"
										x-model="closed"
										@change="if (!closed) private = false"
										class="h-4 w-4 rounded border-stone-300 text-stone-600 focus:ring-stone-500"
									/>
									<label for="group_closed" class="ml-2 text-sm text-stone-700 dark:text-stone-300">
										closed (only invited users can join)
									</label>
								</div>
								<div class="flex items-center">
									<input
										type="checkbox"
										id="group_private"
										name="private"
										x-model="private"
										@change="if (private) closed = true"
										class="h-4 w-4 rounded border-stone-300 text-stone-600 focus:ring-stone-500"
									/>
									<label for="group_private" class="ml-2 text-sm text-stone-700 dark:text-stone-300">
										private (only members can read)
									</label>
								</div>
							</div>
							<button
								type="submit"
								class="px-4 py-2 rounded bg-stone-200 hover:bg-stone-300 dark:bg-stone-700 dark:hover:bg-stone-600 text-stone-700 dark:text-stone-300 font-medium"
								:disabled="creating"
							>
								create group
							</button>
						</form>
					</div>
				}
			}
		</div>
	}
}
